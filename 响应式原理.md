


# 响应式原理


## data响应式数据初始化

### initData
`initData`在`initState`方法体,源码在 `src/core/instance`路径下
```javascript
function initData (vm: Component) {
  let data = vm.$options.data
  // 调用getData 防止触发getter收集依赖
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // data上的key不能与methods上的冲突
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    // data上的key不能与props上的冲突
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      // 代理data上的属性，可以直接用this[key]访问，实际访问的是this._data
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```
从上面看出，`initData`看出对data上的key进行了代理，可以直接通过this[key]来访问this._data[key]上的值,最后再调用`observe(data,true)`对data进行响应式数据初始化。


### observe
`observe`方法位于`src/core/observer/index.js`下，

```javascript
export function observe (value: any, asRootData: ?boolean): Observer | void {
  // 非对象，或者是vnode对象 不进行响应式数据初始化
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  // 如果数据已经响应化了（有__ob__，直接指向Observer实例），直接取__ob__指向的值
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    /**
     * 1.可以响应性化
     * 2.非服务端渲染
     * 3.是对象或者是数组
     * 4.是可扩展的
     * 5.非vue实例
     * 满足上诉5个条件，可响应式化
     */
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    // 只有value 是通过initData -> observe 进来才会进来
    // 当做标识，限制this.$set(this.$data,'key',any)，往根data新增key
    ob.vmCount++
  }
  return ob
}
```
`observe`起到的作用过滤不符合响应式条件的值，以及防止重复new Observer，具体看注释。


### Observer

这个类位于`src/core/observer/index.js`

```javascript
class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    // 新增一个“匡”，用于新增，删除节点时，发送通知给watcher更新
    this.dep = new Dep()
    this.vmCount = 0
    // 定义__ob__指向自身实例，并且不可枚举
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      // 是数组就重写push，unshift等方法，对数据进行拦截，对新增数据响应性话，并且触发更新
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      //循环遍历数组，数组项的对象进行响应式化。
      this.observeArray(value)
    } else {
      // 对象就走这里
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
```
为每个传入的对象或者数组，添加`__ob__`属性指向 Observer实例，如果是数组还对`push`,`pop`等方法进行改写，实现拦截，调用`this.__ob__.dep.notify()`触发更新，如果是对象，就调用`defineReactive`


